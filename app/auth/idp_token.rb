# frozen_string_literal: true

# Copyright (c) 2014 - 2023 UNICEF. All rights reserved.

# Encapsulates the logic to decode and validate a JWT token
# generated by an external identity provider.
class IdpToken
  ALGORITHM = 'RS256'

  attr_accessor :header, :payload, :identity_provider
  attr_writer :session

  class << self
    def build(token_string)
      idp_token = new
      return idp_token unless token_string.present?

      content = decode(token_string)
      return idp_token unless content.present?

      idp_token.payload, idp_token.header = content
      idp_token
    end

    def decode(token_string)
      identity_providers = IdentityProvider.identity_providers
      jwks = IdentityProvider.jwks
      begin
        content = decode_with_jwks(token_string, identity_providers, jwks)
      rescue JWT::DecodeError
        jwks = IdentityProvider.jwks(true)
        content = decode_with_jwks(token_string, identity_providers, jwks)
      end
      content
    end

    def decode_with_jwks(token_string, identity_providers, jwks)
      aud = identity_providers.map(&:client_id)
      iss = identity_providers.map(&:issuer)
      JWT.decode(
        token_string, nil, true,
        algorithm: ALGORITHM, jwks:,
        aud:, verify_aud: true, iss:, verify_iss: true,
        verify_iat: true, verify_expiration: true, verify_not_before: true
      )
    end
  end

  def valid?
    payload.present? && header.present? && unique_id.present?
  end

  def user_name
    email = payload && (payload['emails']&.first || payload['email'])
    unless email.present?
      Rails.logger.error('The claims ‘emails’ or ‘email’ are missing or malformed in the third party JWT')
    end
    email&.downcase
  end

  def issuer
    payload && payload['iss']
  end

  def user
    return @user if @user.present?

    @user = User.joins(:identity_provider).where(
      'users.user_name = ? and identity_providers.configuration @> ?',
      user_name, { issuer: }.to_json
    ).first
  end

  def unique_id
    payload['jti'].presence || payload['nonce'].presence || payload['sub'].presence
  end

  def session
    @session ||= Session.find_by_session_id(unique_id)
  end

  def activate!
    # Do nothing if active or blacklisted session already exists
    return if session

    @session = Session.create!(
      session_id: unique_id, data: { 'warden.user.user.key' => [[user.id], user.user_name] }
    )
  end

  def blacklisted?
    session&.expired?
  end

  def blacklist
    session.destroy
  end
end
